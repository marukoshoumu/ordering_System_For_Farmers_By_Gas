<!-- グローバルローディングオーバーレイ -->
<div class="loading-overlay" id="globalLoading">
  <div class="loading-spinner">
    <div class="spinner"></div>
    <div class="loading-text" id="loadingText">処理中...</div>
  </div>
</div>

<!-- トーストコンテナ -->
<div class="toast-container" id="toastContainer"></div>

<script>
  /* ===============================================
     ユーティリティ関数
     ===============================================

     グローバルローディング、トースト通知を提供します。

     作成日: 2025-12-31
     更新日: 2026-01-01 (トースト追加)
     更新日: 2026-02-01 (calcNextRecurringDate追加)
  */

  /**
   * グローバルローディングを表示
   * @param {string} message - 表示するメッセージ（デフォルト: '処理中...'）
   */
  function showLoading(message) {
    message = message || '処理中...';
    var loadingEl = document.getElementById('globalLoading');
    var textEl = document.getElementById('loadingText');

    if (loadingEl && textEl) {
      textEl.textContent = message;
      loadingEl.classList.add('show');
    }
  }

  /**
   * グローバルローディングを非表示
   */
  function hideLoading() {
    var loadingEl = document.getElementById('globalLoading');

    if (loadingEl) {
      loadingEl.classList.remove('show');
    }
  }

  /**
   * トースト通知を表示
   * @param {string} message - 表示するメッセージ
   * @param {string} type - トーストタイプ ('success', 'error', 'warning', 'info')
   * @param {number} duration - 表示時間（ミリ秒、デフォルト: 3000）
   */
  function showToast(message, type, duration) {
    type = type || 'info';
    duration = duration || 3000;
    
    var container = document.getElementById('toastContainer');
    if (!container) return;

    // トーストアイコン
    var icons = {
      success: '✅',
      error: '❌',
      warning: '⚠️',
      info: 'ℹ️'
    };

    // トースト要素を作成
    var toast = document.createElement('div');
    toast.className = 'toast toast-' + type;
    toast.innerHTML = '<span class="toast-icon">' + icons[type] + '</span><span class="toast-message">' + message + '</span>';

    // コンテナに追加
    container.appendChild(toast);

    // アニメーション開始
    setTimeout(function() {
      toast.classList.add('show');
    }, 10);

    // 自動削除
    setTimeout(function() {
      toast.classList.remove('show');
      setTimeout(function() {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }, duration);
  }

  /**
   * 成功トースト
   * @param {string} message - 表示するメッセージ
   */
  function showSuccessToast(message) {
    showToast(message, 'success');
  }

  /**
   * エラートースト
   * @param {string} message - 表示するメッセージ
   */
  function showErrorToast(message) {
    showToast(message, 'error', 4000);
  }

  /**
   * 警告トースト
   * @param {string} message - 表示するメッセージ
   */
  function showWarningToast(message) {
    showToast(message, 'warning');
  }

  /**
   * 情報トースト
   * @param {string} message - 表示するメッセージ
   */
  function showInfoToast(message) {
    showToast(message, 'info');
  }

  // google.script.run のラッパー関数（エラーハンドリング付き）
  function runWithLoading(functionName, successCallback, errorMessage) {
    showLoading(errorMessage || '処理中...');

    return {
      withSuccessHandler: function(callback) {
        return this.withFailureHandler(function(error) {
          hideLoading();
          showErrorToast('エラーが発生しました: ' + error);
        })[functionName](callback);
      },
      withFailureHandler: function(callback) {
        var self = this;
        return {
          [functionName]: function(successCallback) {
            google.script.run
              .withSuccessHandler(function(result) {
                hideLoading();
                if (successCallback) successCallback(result);
              })
              .withFailureHandler(function(error) {
                hideLoading();
                showErrorToast('エラーが発生しました: ' + error);
                if (callback) callback(error);
              })
              [functionName]();
          }
        };
      }
    };
  }

  /**
   * 基準日と定期タイプから次回発送日を計算
   * @param {Date|string} baseDate - 基準日
   * @param {string} type - 定期タイプ ('weekly', 'biweekly', 'triweekly', 'monthly', '2month', '3month', または 'nweek'形式)
   * @param {string|number} subValue - サブ値（曜日番号1-7、月の日付1-31、'first'、'last'）
   * @returns {Date|null} 次回発送日、無効な場合はnull
   */
  function calcNextRecurringDate(baseDate, type, subValue) {
    var d = new Date(baseDate);
    if (isNaN(d.getTime())) return null;
    // 曜日計算のずれ防止: カレンダー日のみに正規化（ローカル日付で再構築）
    var y = d.getFullYear(), m = d.getMonth(), day = d.getDate();
    d = new Date(y, m, day);

    if (type === 'weekly') {
      // 毎週: 発送日から最低7日後の指定曜日
      var targetDay = Number(subValue) || 1;
      var currentDay = d.getDay() || 7;
      var diff = (targetDay - currentDay + 7) % 7;
      if (diff === 0) diff = 7;
      // 次回発送日は少なくとも1週間後
      if (diff < 7) diff += 7;
      d.setDate(d.getDate() + diff);
      return d;
    } else if (type === 'biweekly' || type === 'triweekly' || type.endsWith('week')) {
      // 指定曜日をベースにし、その日から n 週間後を次回発送日とする（recurringOrderCode.js と同一ロジック）
      var n = type === 'biweekly' ? 2 : type === 'triweekly' ? 3 : parseInt(type.replace('week', '')) || 2;
      var weekday = Number(subValue) || 1;
      var currentDay2 = d.getDay() || 7;
      var daysToAnchor = (weekday - currentDay2 + 7) % 7;
      if (daysToAnchor === 0) {
        d.setDate(d.getDate() + 7 * n);
      } else {
        d.setDate(d.getDate() + daysToAnchor + 7 * n);
      }
      return d;
    } else if (type === 'monthly') {
      if (subValue === 'first') {
        d.setMonth(d.getMonth() + 1, 1);
      } else if (subValue === 'last') {
        d.setMonth(d.getMonth() + 2, 0);
      } else {
        var targetDayOfMonth = Number(subValue) || 1;
        d.setMonth(d.getMonth() + 1);
        var lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
        d.setDate(Math.min(targetDayOfMonth, lastDay));
      }
      return d;
    } else if (type === '2month' || type === '3month') {
      // 月の日付を保持しつつ、月末調整を行う
      var targetDayOfMonth = d.getDate();
      var months = parseInt(type.replace('month', '')) || 1;
      d.setMonth(d.getMonth() + months);
      var lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
      d.setDate(Math.min(targetDayOfMonth, lastDay));
      return d;
    }
    return null;
  }
</script>
